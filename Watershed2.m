function [bw_stats,greenTherhold,Boundaries_Are_Important] = Watershed2(r,g,b,name,MinNucVox,observe)
%
% Watershed2 performs 3D controlled watershed segmentation on the subvolumes 
% created in the function imreadVolume and returns the cell boundaries. Five 
% inputs are required for this function with one optional input. The first 
% three inputs are the subvolumes returned from imreadVolume, which are the 
% variables [r,g,b]. The fourth input is the filename which is used to label 
% the histogram so the user can identify which image the histogram was 
% generated from. The final optional input is a boolean which if true uses 
% the function WatershedObserver to show the ridgelines and ROIs identified 
% as single cells. ROIs are color coded and presented using labelvolshow. 
% After viewing the labels and ridgelines the volume data for the cell 
% boundaries is shown as a 3D Maximum Intensity Projection.  
% Here Otsu’s method is used to determine a global histogram threshold for 
% each subvolume, so volume data requires an adequate signal to noise ratio 
% for proper utilization. Also, expects the volume data to encompass the 
% entire cell structure in 3 dimensions.
% 
% As written both the eGFP and mCherry channels undergo Otsu’s thresholding 
% and their respective histograms are reported. However, only the eGFP 
% channel is used to mark the cell membrane boundaries as it is known to have 
% the higher fluorescence output per fluorophore aka brightness (brightness 
% is proportional to the product of the extinction coefficient, at the 
% relevant excitation wavelength, and the fluorescence quantum yield) [1]. 
% eGFP also performed the best segmentation for the cell line used for 
% testing this function as it produced a higher level of endogenous 
% cytoplasmic signal which was used for identifying cell boundaries. This can
% be changed manually if a user believes the mCherry channel or the 
% combination of the eGFP and mCherry channels would perform better for their 
% cell line. 
% 
% The cell masks found in the 3D controlled watershed segmentation are passed
% to regionprops3 to get stats for later use. The structure generated by 
% regionsprops3 is returned from this function and is used in the function 
% FindVacuoles which uses the structure to perform single cell analysis.
% 
% See these links for more information on the attributes for these 
% fluorescent proteins and for terminology: 
% 
% https://www.thermofisher.com/us/en/home/references/molecular-probes-the-handbook/introduction-to-fluorescence-techniques.html
% https://www.fpbase.org/protein/egfp/
% https://www.fpbase.org/protein/mcherry/
% 
% Reference 
% Fluorescence fundamentals. Available at: https://www.thermofisher.com/us/en/home/references/molecular-probes-the-handbook/introduction-to-fluorescence-techniques.html. (Accessed: 14th May 2021) 
% 
%  Created by: Joaquin Quintana (last modified: 05-18-2021)      
%  Email: Joaquin.Quintana@Colorado.edu

close all; 

%tell user what image these plots were created from

disp('Data for plots generated from - ' + string(name));

%try adjusting volume data for to improve biomodial histogram segmentation
%didn't really make a difference for my data.
adjg= imadjustn(g);adjr= imadjustn(r);adjb= imadjustn(b);

%format string for histogram 
formatSpecG = "%s - Histogram eGFP Voxel Intensities";
formatSpecR = "%s - Histogram mCherry Voxel Intensities";
formatSpecB = "%s - Histogram Nuclear Marker Voxel Intensities";
Ghist_Header = sprintf(formatSpecG,name);
Rhist_Header = sprintf(formatSpecR,name);
Bhist_Header = sprintf(formatSpecB,name);
Red_threshold_String = "mCherry Threshold: %f";
Green_threshold_String = "eGFP Threshold: %f";
Nuclear_threshold_String = "Nuclear Marker Threshold: %f";

%maximize figure window
figure('WindowState','maximized');
%% Otsu's Thresholds and Histograms
subplot(3,1,1);
title(Ghist_Header);
set(gca,'Color','k')
[gcounts,gx] = imhist(adjg,100);hold on;
stem(gx,gcounts,...
     'MarkerFaceColor','y',...
     'MarkerEdgeColor','k')
greenTherhold = otsuthresh(gcounts);hold on;
line([greenTherhold, greenTherhold], ylim, 'LineWidth', 1, 'Color', 'r',...
    'LineStyle', '--');
%Theshold value annotation
ThreshPrintG = sprintf(Green_threshold_String,greenTherhold);

%Subplot for mCherry Otsu's histogram
subplot(3,1,2);
set(gca,'Color','k')
%get counts from histogram and specify bin number
[rcounts,rx] = imhist(adjr,100); hold on;
%use stem to show data in bins
stem(rx,rcounts,...
     'MarkerFaceColor','y',...
     'MarkerEdgeColor','k')
%header
title(Rhist_Header);
%pass rcounts to otsuthresh to perform thresholding
redThreshold = otsuthresh(rcounts);
%place a redline on the histogram specifying the threshold determined 
line([redThreshold, redThreshold], ylim, 'LineWidth', 1, 'Color', 'r',...
    'LineStyle', '--');
%Theshold value annotation
ThreshPrintR = sprintf(Red_threshold_String,redThreshold);


%Subplot for nuclear marker Otsu's histogram
subplot(3,1,3);
set(gca,'Color','k')
%get counts from histogram and specify bin number
[bcounts,bx] = imhist(adjb,100); hold on;
%use stem to show data in bins
stem(bx,bcounts,...
     'MarkerFaceColor','y',...
     'MarkerEdgeColor','k')
%header
title(Bhist_Header);
%using a different but similar Otsu's method for nuclear marker 
nucThresh = graythresh(adjb);
%place a redline on the histogram specifying the threshold determined 
line([nucThresh, nucThresh], ylim, 'LineWidth', 1, 'Color', 'r',...
    'LineStyle', '--');
%Theshold value annotation
nucPrintR = sprintf(Nuclear_threshold_String,nucThresh);

%place annotation in upper right corner of each subplot by using horzonatal
%alignment 
a(1) = subplot(3,1,1);
adjb(1) = annotation('textbox','String',ThreshPrintG,'Position',a(1).Position,...
    'HorizontalAlignment','right','Color','w','FitBoxToText','on');

a(2) = subplot(3,1,2);
adjb(2) = annotation('textbox','String',ThreshPrintR,'Position',a(2).Position,...
    'HorizontalAlignment','right','Color','w','FitBoxToText','on');

a(3) = subplot(3,1,3);
adjb(3) = annotation('textbox','String',nucPrintR,'Position',a(3).Position,...
    'HorizontalAlignment','right','Color','w','FitBoxToText','on');

snapnow()
%Note imbinarize is identical to the threshold returned by graythresh, but
%I figured for the purpose of keeping this consistents with the historgram 
%I would pass the threshold produced by graythresh to imbinarize. Probably
%unnecessary.

%binarize the nuclear channel and remove objects that have fewer than 1000
%connected components
Nuclei = bwareaopen(imbinarize(adjb,nucThresh),1000);

%rename the eGFP channel Members_of_membrane to denote this is used for
%cell membrane boundaries
Members_of_membrane = (adjg);

%Find gradient magnitude and direction of volume
Gmag = imgradient3(Members_of_membrane);

%get the distance transform of binary image and convert to double
Distance = im2double(bwdist(Nuclei));

%use distance transform to calculate the watershed transform. 
DwaterShed = im2double(watershed(Distance));

%Set pixels that are outside the ROI to 0. This is the RidgeLine of the
%watershed
RidgeLineFinder = DwaterShed == 0;

%use imimposemin to modify volume so that it has regional minima only in
%desired locations. Helps control the final watershed
GradientMag3 = imimposemin(Gmag, RidgeLineFinder | Nuclei);

%Regions of interests found by controlled watershed segmentation
ROIs = im2double(~watershed(GradientMag3));

%clean up small objects that are not of interst if the exist and call final
%single cell ROIs Boundaries_Are_Important
Boundaries_Are_Important = bwareaopen(ROIs>0,100);

%remove containers which are to small to be full cell boundaries
cc = bwconncomp(Boundaries_Are_Important); 

%use the MinNucVox volume input by user to remove any objects that might be
%placed on the borders which are useless
stats = regionprops3(cc,'Volume'); 
idx = find([stats.Volume] > MinNucVox); 
Boundaries_Are_Important = ismember(labelmatrix(cc),idx);

% use the cell masks found in the 3D controlled watershed segmentation to 
% get stats from regionprops3. Return the structure generated by regionsprops3 for
% use in function FindVacuoles which uses it to perform single cell analysis.
bw_stats = regionprops3(Boundaries_Are_Important,g,'all');

%make Boolean input optional for viewing the Ridgelines and single cell
%containers. If ture 

    if ((~exist('observe','var')) || (observe == false))
        observe = false;
    end

    if observe == true 
        WatershedObserver(g,Boundaries_Are_Important,...
           RidgeLineFinder);
    end

end